<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>RESTful架构之我见</title>
      <link href="2020/12/29/RESTful%E6%9E%B6%E6%9E%84%E4%B9%8B%E6%88%91%E8%A7%81/"/>
      <url>2020/12/29/RESTful%E6%9E%B6%E6%9E%84%E4%B9%8B%E6%88%91%E8%A7%81/</url>
      
        <content type="html"><![CDATA[<h2 id="REST是什么"><a href="#REST是什么" class="headerlink" title="REST是什么"></a>REST是什么</h2><p>REST全称是REpresentational State Transfer（表述性状态转移）。这种架构风格思想最初在2000年发表在Roy Thomas Fielding的博士论文《Architectural Styles andthe Design of Network-based Software Architectures》。在这篇论文里他同时也阐述了关于HTTP和URL的设计思想。值得一读。</p><h2 id="对REST的理解"><a href="#对REST的理解" class="headerlink" title="对REST的理解"></a>对REST的理解</h2><p>REST从名字上看，就是把状态转移的行为（用文字）具象表现出来。通过转移和操作资源的表述，来间接实现操作资源的目的。论文作者对具有REST性质的架构风格进行约束。其目的是为了让分布式架构最大程度的松耦合，不让客户端依赖于特定的服务器。</p><p>论文作者对其架构风格做出了如下约束</p><ul><li><p>C/S模式</p><p>  这个条件最为重要，让表述不依赖于特定的服务器或者特定的客户端，降低耦合性</p></li><li><p>分层</p><p>  表达式不依赖于特定的协议，这样可以让不相邻的底层方便对条件状态的处理自行选择怎么处理，比如可以忽略请求，或者用代理中转实现负载均衡。</p></li><li><p>统一接口</p><p>  作者认为一个能表述状态转移的接口必须是统一的，而不能针对某个特定的情况下就行特定化。将命令和实现分开。要做到统一接口，还想要以下条件</p></li></ul><ol><li>资源的识别</li><li>通过表达式来对资源进行操作</li><li>有自描述消息（一个消息提供的信息足够多描述怎么处理的信息，比如说我可以通过HTTP的media type来指定浏览器应该用什么格式的解析器）</li><li>超媒体作为应用状态的引擎（就是程序通过初始的URI返回的内容作为程序初始的启动参数）</li></ol><ul><li><p>无状态</p><p>  无状态个人认为它简化了程序的设计，提高程序的扩展性，不必在保存各种状态信息，服务端可以通过数据的ID来对其进行处理。</p></li><li><p>缓存</p><p>  计算机中缓存的作用就是保存常用的信息，资源中很多资源是静态的，很少对其进行改动。</p></li><li><p>按需编码（可选）</p><p>  客户端可以通过服务器返回的内容提供功能。比如浏览器可以通过服务器提供的HTML渲染出用户界面。</p></li></ul><h2 id="RESTful风格"><a href="#RESTful风格" class="headerlink" title="RESTful风格"></a>RESTful风格</h2><p>符合REST设计风格的Web API称为RESTful API。在我的理解看来，RESTful具体到了HTTP上，充分利用了HTTP协议的语义。比如在HTTP协议的第一行，有如下表述形式</p><p>GET /zoo/panda?id=100</p><p>POST /school/senior/student</p><p>DELETE /school/senoir/students/200</p><p>左边是一个动词，右边是一个名词，名词也充分利用了路径的表达意义，使整个表述有更简明的意思。相比于RPC，个人觉得RESTful架构风格更清晰地诠释了这些动作。想象一下上面的名词是某个文件上的路径，你会感觉这这样的描述更符合我们对文件的操作。</p><p>同样我们也不难其他RESTful API的规范要求了</p><ul><li>尽量将API部署在专用域名之下，比如api.example.com。这么做的目的就是为了让客户端不特定依赖某个IP的服务器。</li><li>将API的版本号放入URL中，这么做的目的是为了解耦，使其兼容不同版本的客户端。</li><li>返回状态码（有错误同时返回错误信息）。这么做的目的也是为了让客户端能知晓服务器是否正确处理了这些信息。</li><li>Hypermedia API，让客户端能通过Hypermedia API返回的结果来提供可变的服务。</li></ul><h2 id="REST的缺点"><a href="#REST的缺点" class="headerlink" title="REST的缺点"></a>REST的缺点</h2><p>当然，这个架构也并不是全是优点，他也有相对应的缺点</p><ul><li>性能弱，由于传输信息时有用信息占比低，会导致性能不如RPC这种。</li><li>不太适合表达行为，不如登录操作和登出操作，以及函数调用等。</li></ul><p>总之，REST架构风格是面向资源的设计风格，优点来自于它，缺点也来自于它</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>详细设计</title>
      <link href="2020/06/12/%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1/"/>
      <url>2020/06/12/%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>详细设计</p><ul><li>决定了最终的程序代码质量</li><li>根本目标：确定应该怎样具体的实现</li></ul><p>结构程序设计</p><ul><li>可以只用三种结构实现任何单入口单出口的程序</li><li>经典定义：代码只用顺序、选择和循环三种基本控制结构进行连接，并且每个代码块只有一个人口和一个出口，程序为结构化的。</li><li>在允许使用break则为修正的结构程序设计</li></ul><p>人机界面设计</p><ol><li>系统响应时间<br>系统响应时间应该适中，每次响应时间应该差距小</li><li>用户帮助设施</li><li>出错信息处理</li><li>命令交互</li></ol><p>过程设计工具</p><ul><li>程序流程图</li><li>盒图</li><li>PAD图<br>使用PAD图的必然是结构化程序，主线清晰</li><li>判定表</li><li>判定树</li><li>伪代码</li></ul><p>面向数据结构的设计方法<br>- </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>总体设计</title>
      <link href="2020/06/11/%E6%80%BB%E4%BD%93%E8%AE%BE%E8%AE%A1/"/>
      <url>2020/06/11/%E6%80%BB%E4%BD%93%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>总体</p><ul><li>目的：回答怎么实现系统的问题</li><li>任务<ul><li>设计软件的结构</li><li>划分出组成系统的物理元素</li></ul></li><li>必要性：以较少的成本，高层次对比多种方案，选出最佳的</li><li>基础：需求阶段得到的数据流图</li></ul><p>设计过程</p><ul><li>阶段<ol><li>系统设计阶段</li><li>结构设计阶段</li></ol></li><li>步骤<ol><li>设想供选择的方案</li><li>选取合理的方案<br>至少选取低成本、中成本、高成本的方案</li><li>推荐最佳方案</li><li>功能分解</li><li>设计软件结构</li><li>设计数据库</li><li>制定测试计划</li><li>书写文档</li><li>审查和复审</li></ol></li></ul><p>设计原理</p><ul><li>模块化</li></ul><p>模块是程序的基本构件。模块化是把程序划分为可以独立命名且能独立访问的模块,可以让软件结构更加清晰，让软件容易测试与调试，提高修改性，有助于软件开发的组织管理，要控制模块数量</p><ul><li>抽象</li></ul><p>抽象是提取相似的方面暂时忽略个体之间的差异</p><ul><li>逐步求精</li></ul><p>一个人在任何时候只能把注意力放在72个知识块上</p><ul><li>信息隐藏和局部化</li></ul><p>模块应该隐藏实现的细节</p><ul><li>模块独立</li></ul><p>模块独立是好设计的关键。其一，有效的模块化更容易开发；其二，独立的模块更容易调试测试</p><p>耦合</p><ol><li>数据耦合</li><li>控制耦合</li><li>特征耦合</li><li>公共环境耦合</li><li>内容耦合</li></ol><p>内聚</p><ol><li>功能内聚</li><li>顺序内聚</li><li>通信内聚</li><li>过程内聚</li><li>时间内聚</li><li>逻辑内聚</li><li>偶然内聚</li></ol><p>启发规则</p><ol><li>改进软件结构提高模块独立性</li><li>模块规模应该适中</li><li>深度、宽度、扇入、扇出应该适当</li><li>模块的作用域应该在控制域中心</li><li>力争降低模块接口的复杂程度</li><li>设计单入口单出口的模块</li><li>模块功能应该可以预测</li></ol><p>图形工具</p><ol><li>层次图</li><li>IPO图</li><li>结构图</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>需求分析</title>
      <link href="2020/06/10/%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/"/>
      <url>2020/06/10/%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>任务</p><ol><li>确定对系统的综合要求<ol><li>功能需求</li><li>性能需求</li><li>可靠性和可用性需求</li><li>出错处理需求</li><li>接口需求</li><li>约束</li><li>逆向需求</li><li>将来可能提出的要求</li></ol></li><li>分析系统的数据要求<br>软件分析的重要任务，可以用层次方框图和Warnier图</li><li>导出系统的逻辑模型</li><li>修正系统开发计划</li></ol><p>用户沟通获取需求的方法</p><ol><li>访谈</li><li>面向数据流自顶向下求精</li><li>简易的应用规格说明技术</li><li>快速建立软件原型</li></ol><p>ER图</p><p>数据规范化</p><p>状态转换图</p><p>层次方框图</p><p>WArnier图</p><p>IPO图</p><p>验证软件需求</p><ul><li>方面：<ul><li>一致性</li><li>完整性</li><li>现实性</li><li>有效性</li></ul></li><li>方法：<ul><li>验证需求的一致性</li><li>验证需求的现实性</li><li>验证需求的完整性和有效性</li></ul></li><li>工具：<ul><li>RSL</li><li>RSA</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>可行性研究</title>
      <link href="2020/06/10/%E5%8F%AF%E8%A1%8C%E6%80%A7%E7%A0%94%E7%A9%B6/"/>
      <url>2020/06/10/%E5%8F%AF%E8%A1%8C%E6%80%A7%E7%A0%94%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<p>可行性研究（占总成本的5%~10%）</p><ul><li>目的：最小代价尽可能短的时间确定问题能否解决</li><li>实质：大幅度简化压缩的系统分析和设计</li><li>三要素：<ol><li>技术</li><li>经济</li><li>操作</li></ol></li><li>根本：对以后的行动方针提出建议</li><li>步骤：<ol><li>复查系统规模和人员</li><li>研究目前正在使用的系统</li><li>导出新系统的高层逻辑模型</li><li>进一步定义问题</li><li>导出和评价供选择的解法</li><li>推荐行动方针</li><li>草拟开发计划</li><li>书写文档提交审查</li></ol></li></ul><p>系统流程图</p><ul><li>逻辑图-&gt;物理模型</li><li>描述物理模型的传统模型</li></ul><p>数据流图</p><ul><li>描述数据的逻辑过程，系统逻辑功能的图形表示</li></ul><p>数据字典</p><ul><li>组成<ul><li>数据流</li><li>数据元素</li><li>数据存储</li><li>处理</li></ul></li><li>数据元素组成数据的方式：<ul><li>顺序</li><li>选择</li><li>重复</li><li>可选</li></ul></li><li>开发数据库的第一步</li><li>实现：<ul><li>名字</li><li>别名</li><li>描述</li><li>定义</li><li>位置</li></ul></li></ul><p>成本估计</p><ul><li>代码行技术</li><li>任务分解技术</li><li>自动估计成本技术</li></ul><p>成本效益分析方法（默认生命周期为5年）</p><ol><li>货币的时间价值（按复利计算）</li><li>投资回收期</li><li>纯收入</li><li>投资回收率</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>软件工程总结第一章</title>
      <link href="2020/06/09/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%80%BB%E7%BB%93%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
      <url>2020/06/09/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%80%BB%E7%BB%93%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="软件工程概述"><a href="#软件工程概述" class="headerlink" title="软件工程概述"></a>软件工程概述</h2><p>软件危机：软件开发和维护过程遇到的严重问题</p><ul><li>​包含的问题：<ol><li>如何开发软件 </li><li>如何维护数量膨胀的已有软件</li></ol></li><li>典型表现：<ol><li>未准确估计软件开发成本及其进度</li><li>软件成本占计算机系统总成本的比重越来越大</li><li>软件质量往往不可靠</li><li>软件常常不可维护</li><li>没有适当的文档</li><li>用户对软件成品不满意</li><li>软件开发速度不如计算机普及速度</li></ol></li><li>产生原因：<ul><li>软件本身的特点</li><li>开发和维护不正确</li></ul></li><li>消除办法：<ol><li>正确认识软件</li><li>认识到软件是个大型工程项目</li><li>推广开发经验和技术</li><li>使用更好的工具</li></ol></li></ul><p>软件</p><ul><li>定义：</li></ul><p>软件工程</p><ul><li>定义：研究系统、规范、可量化的办法并将其用于开发运行和维护软件</li><li>特性：<ol><li>关注大型工程的构造</li><li>中心是控制复杂度</li><li>软件经常变化</li><li>注重开发效率</li><li>要和谐合作</li><li>软件必须有效支持其用户</li><li>常常跨领域开发</li></ol></li><li><p>基本原理</p><ol><li>用分阶段的生命周期计划严格执行</li><li>坚持阶段评审</li><li>实行严格的产品控制</li><li>采用现代程序设计</li><li>能清楚审查结果</li><li>开发小组成员应少而精</li><li>承认不断改造软件工程实践的必要性</li></ol></li><li><p>方法学（范型）：方法工具和过程</p><ol><li>传统方法学：以软件生命周期为主线，分阶段开发</li><li>面向对象方法学：以数据为中心，把数据和操作数据的方法绑定在一起</li></ol></li></ul><p>软件生命周期</p><ul><li>组成：软件定义、软件开发、运行维护</li><li>阶段<ol><li>问题定义</li><li>可行性研究</li><li>需求分析（软件定义）</li><li>总体设计</li><li>详细设计（系统设计）</li><li>编码和单元测试</li><li>综合测试（系统实现）</li><li>软件维护</li></ol></li></ul><p>软件过程</p><ul><li>定义：为了获取高质量软件所需要完成的一系列任务的框架。（通常用生命周期模型描述）</li></ul><p>瀑布模型</p><ul><li>最广泛，传统方法学表达的有力工具，文档驱动，实际带反馈环</li><li>特点：<ol><li>阶段间有顺序性和依赖性</li><li>推迟实现的观点：尽可能推迟物理实现</li><li>质量保证的观点</li></ol></li><li>缺点：基本靠文档，可能导致产品最终不能满足用户</li></ul><p>快速原型模型</p><ul><li>优点：不带反馈环，软件开发基本为线性</li></ul><p>增量模型（渐增模型）</p><ul><li>将软件变成一系列的增量构件设计编码集成设计</li><li>优点：开发风险小</li><li>缺点：集成风险大</li></ul><p>螺旋模型</p><p>喷泉模型</p><ul><li>典型的面向对象的软件过程之一</li></ul><p>Rational统一过程（RUP）</p><ul><li>最佳实践<ol><li>迭代开发</li><li>管理需求</li><li>基于构建的体系结构</li><li>可视化建模</li><li>验证软件质量</li><li>控制软件变更</li></ol></li><li>生命周期</li></ul><p>敏捷过程</p><ul><li>开发宣言<ol><li>个体和交互胜过工具和过程</li><li>可以工作的软件胜过面面俱到的文档</li><li>客户合作胜过合同谈判</li><li>响应变化胜过遵循计划</li></ol></li></ul><p>极限编程</p><ul><li>代码重构</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>傅里叶变换推导</title>
      <link href="2020/03/16/fourierer-transform/"/>
      <url>2020/03/16/fourierer-transform/</url>
      
        <content type="html"><![CDATA[<p>假设函数f(x)是有周期变化的,且周期为T,则可将函数设成</p><p>$f(x)=C+\sum\limits_{n=1}^{\infty}(a_ncos(\frac{2πn}{T}x)+b_nsin(\frac{2πn}{T}x)) (\frac{2πn}{T}是为了保证其周期为T)$<br>而</p><script type="math/tex; mode=display">e^{i\theta} = \cos\theta+i\sin\theta</script><p>可推出</p><script type="math/tex; mode=display">\sin\theta = \frac{e^{i\theta}-e^{-i\theta}}{2i} \\\cos\theta = \frac{e^{i\theta}+e^{-i\theta}}{2}</script><p>将其化简可得</p><script type="math/tex; mode=display">f(x) = \sum_{n=-\infty}^{\infty}c_n e^{i\frac{2πnx}{T}}</script><p>其中</p><script type="math/tex; mode=display">c_n = \frac{1}{T}\int_{x_0}^{x_0+T}f(x)e^{-i\frac{2πnx}{T}}dx</script><p>现在我有一组时域上的N个数据，我们将其视这些数据为一个周期，则根据上式的意义（求平均数），有</p><script type="math/tex; mode=display">c_n = \frac{1}{N}\sum_{x = 1}^{N}f(x)e^{-i\frac{2πnx}{N}}</script>]]></content>
      
      
      
        <tags>
            
            <tag> 傅里叶变换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初等概率论和统计学</title>
      <link href="2019/11/19/%E7%BB%9F%E8%AE%A1%E5%AD%A6/"/>
      <url>2019/11/19/%E7%BB%9F%E8%AE%A1%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="初等概率论基本概念"><a href="#初等概率论基本概念" class="headerlink" title="初等概率论基本概念"></a>初等概率论基本概念</h2><ul><li>随机试验 特点：<ol><li>在相同的条件下试验可大量地重复 </li><li>进行一次试验不确定哪个结果会出现</li><li>试验结果不止一个，而且能明确试验的所有可能结果</li></ol></li><li>样本空间： 随机试验E的所有可能结果的集合</li><li>样本点：样本空间的元素</li><li>随机事件：样本空间S的子集（由一个样本点组成的集合叫基本事件）</li><li>必然事件：样本空间S</li><li>不可能事件：Ø</li></ul><h3 id="事件的关系和运算"><a href="#事件的关系和运算" class="headerlink" title="事件的关系和运算"></a>事件的关系和运算</h3><ol><li>事件B包含事件A：若A发生则B一定发生（若相互包含则A=B，两事件相等）</li><li>和事件:事件$A∪B=\{x|x∈A或x∈B\}$</li><li>积事件:事件$A∩B=\{x|x∈A且x∈B\}$</li><li>差事件:事件$A-B=\{x|x∈A且x∉B\}$</li><li>互斥事件:$A∩B=Ø$</li><li>对立事件:$A∩B=Ø且A∩B=S$</li></ol><h3 id="频率和概率"><a href="#频率和概率" class="headerlink" title="频率和概率"></a>频率和概率</h3><ul><li>频数$n_A$：事件A已经发生的次数</li><li>频率$f_n(A)$：进行了n次实验，事件A的频数$n_A$与n的比值</li></ul><p>频率性质：</p><ol><li>$0 \le f_n(A) \le 1$</li><li>$f_n(S) = 1$</li><li>$A_i(i=1,2,3,…k)$两两互斥，则$f_n(A_1∪A_2…∪A_k) =  f_n(A_1)+f_n(A_2)…+f_n(A_k)$</li></ol><p>事实表明，试验次数n逐渐增大，频率f_n(A)也逐步稳定在某个常数，这种稳定性就是通常所说的统计规律性，但实际不可能多次试验求得频率。为了理论研究方便，概率就这样产生了</p><p>概率：对于随机试验E的每一个事件A赋予一个实数记为P(A),称为事件A的概率。且要满足以下条件：</p><ol><li>对于一个事件A,$P(A) \ge 0$</li><li>必然事件S，$P(S) = 1$</li><li>$A_i(i=1,2,3,…)$两两互斥,$P(A_1∪A_2…) =  P(A_1)+P(A_2)…$</li></ol><p>概率性质:</p><ol><li>$P(Ø) = 1$ （证明：构造n个空集的加事件求概率）</li><li>$A_i(i=1,2,3,…k)$两两互斥,$P(A_1∪A_2…∪A_k) =  P(A_1)+P(A_2)…+P(A_k)$ （可列可加推导而来）</li><li>B包含A 有$P(B-A) = P(B) - P(A)$ $P(B) \ge P(A)$</li><li>$P(A) \le 1$ (S包含A)</li><li>$P(\overline{A}) = 1 - P(A)$</li><li>$P(A∪B) = P(A) + P(B) - P(AB)$(利用差事件)</li></ol><h3 id="古典概型"><a href="#古典概型" class="headerlink" title="古典概型"></a>古典概型</h3><p>前提条件</p><ol><li>样本空间是有限集</li><li>每个基本事件发生的概率等可能</li></ol><p>$P(A) = \frac{A包含的基本事件数}{S中基本事件数}$</p><h3 id="几何概型"><a href="#几何概型" class="headerlink" title="几何概型"></a>几何概型</h3><p>前提条件</p><ol><li>样本空间是无限集</li><li>每个基本事件发生的概率等可能</li></ol><p>$P(A) = \frac{A在某个标准下的测度}{S在某个标准下的测度}$</p><h3 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h3><p>A,B是2个事件，且$P(A) &gt; 0$,称<br>$P(B|A) = \frac{P(AB)}{P(B)}$（直观理解：事件A里发生事件B的概率）<br>同样，条件概率也是概率，满足概率的基本特点。</p><p>条件概率的定义可以得到以下定理：<br>$P(AB) = P(B|A)P(A)$<br>拓展到3个事件也有<br>$P(ABC) = P(C|BA)P(B|A)P(A)$<br>同样可以推导n个事件</p><p>这样我们可以通过这个定理推出贝叶斯公式：<br>$P(B|A) = \frac{P(A|B)P(B)}{P(A)}$</p><h3 id="独立性"><a href="#独立性" class="headerlink" title="独立性"></a>独立性</h3><p>独立性的直观感觉是，一个事件不会影响到其他事件的发生与否。反应到概率里就是2个独立事件同时发生的概率是2个事件的概率直接相乘。<br>如果A,B2个事件满足$P(AB) = P(A)P(B)$,则A、B相互独立。<br>推广到n个事件，一个事件A不会影响到其他任何事件（包括集事件）的发生与否，这才是独立。</p><h2 id="随机变量及其分布"><a href="#随机变量及其分布" class="headerlink" title="随机变量及其分布"></a>随机变量及其分布</h2><h2 id="统计学科"><a href="#统计学科" class="headerlink" title="统计学科"></a>统计学科</h2><h3 id="统计学派"><a href="#统计学派" class="headerlink" title="统计学派"></a>统计学派</h3><ol><li>国势学派：通过对比分析分析国家的组织、领土、人口等资源。</li><li>概率论学派：开始使用可度量的方法，力求使用数字解释现实</li><li>数理统计学派：将概率论引入统计学</li><li>社会统计学派：对社会做大量的调查</li></ol><blockquote><p>我们所学的是数理统计，可以将样本中的个体视为单独的随机变量，统计学的很多东西也是由这个思想而来。概率论和数理统计只有一个概率论的核心。</p><h3 id="统计学分类"><a href="#统计学分类" class="headerlink" title="统计学分类"></a>统计学分类</h3></blockquote><ul><li>描述统计：使用图表、概括性数字等对数据进行描述</li><li>推断统计：通过给定数据推断总体特征</li></ul><h3 id="统计学常用概念（意会即可）"><a href="#统计学常用概念（意会即可）" class="headerlink" title="统计学常用概念（意会即可）"></a>统计学常用概念（意会即可）</h3><ol><li>总体：要研究的所有基本单位的总和（和样本一样大量 同质 差异）</li><li>个体：总体的构成单位</li><li>样本：从总体抽取的部分个体组成的集合（样本容量&gt;=30称为大容量，否则为小容量）</li><li><p>定性数据：不用或者不能用具体数值描述的数据</p><ul><li>定类数据：表示数据特定特征或类型的数据，比如：人的性别</li><li>定序数据：表示的特征或类型能比较的数据，比如：淘宝的商品星级</li></ul></li><li><p>定量数据：能用具体数值量化的数据</p><ul><li>定距数据：有间隔特征的数据，有单位但没有绝对零点的数据，比如：温度</li><li>定比数据：有测量单位，也有绝对零点的数据，比如：身高、体重。</li></ul></li><li><p>抽样误差：样本的抽取得到的结果和总体特征的差距（不可避免）</p></li><li><p>非抽样误差:由于调查过程中的失误造成的误差</p></li></ol><h2 id="统计数据的描述"><a href="#统计数据的描述" class="headerlink" title="统计数据的描述"></a>统计数据的描述</h2><h3 id="统计数据分组"><a href="#统计数据分组" class="headerlink" title="统计数据分组"></a>统计数据分组</h3><p>原则：</p><ol><li>组内同质性</li><li>组间差质性</li></ol><p>过程：</p><ol><li>选择分组标志。品质标志（性别、学历）或者数量标志（身高、体重）</li><li>分组方法：<ul><li>单变量值分组（离散数据，变量少）</li><li>组距分组（数值型数据，变量多）（一般上组限不算在组里）</li></ul></li></ol><h3 id="分布集中程度指标"><a href="#分布集中程度指标" class="headerlink" title="分布集中程度指标"></a>分布集中程度指标</h3><ul><li>众数：一组数据中出现次数最多的数据（可以没有，也可以不只一个）</li><li>中位数：数据排序后，位置在最中间的数</li><li>分位数：</li><li>均值：就是算术平均数，</li><li>几何平均数：n个数连乘的n次方根</li><li>切尾均值：同时去掉两端若干数后的均值</li></ul><h3 id="分布离散程度指标"><a href="#分布离散程度指标" class="headerlink" title="分布离散程度指标"></a>分布离散程度指标</h3><ul><li>极差：最大值与最小值之差</li><li>内距：上四分位数与下四分位数之差</li><li>方差：离差平方的平均数</li><li>标准差：方差的平方根</li><li>离散系数(变异系数)：标准差与均值之比</li></ul><h3 id="分布形态指标"><a href="#分布形态指标" class="headerlink" title="分布形态指标"></a>分布形态指标</h3><ul><li>偏态</li><li>峰度</li></ul><h3 id="频率分布直方图"><a href="#频率分布直方图" class="headerlink" title="频率分布直方图"></a>频率分布直方图</h3><ul><li>平均数：（组内平均数）* 次数/总次数</li><li>中位数：使整体面积能分成一半的点</li><li>众数：</li></ul><h2 id="参数估计"><a href="#参数估计" class="headerlink" title="参数估计"></a>参数估计</h2><p>参数估计是指通过抽取的样本来预估总体的某些指标，有2种方法</p><ol><li>点估计</li><li>区间估计</li></ol><h3 id="评价估计量的标准"><a href="#评价估计量的标准" class="headerlink" title="评价估计量的标准"></a>评价估计量的标准</h3><ol><li><p>无偏性:<br>如果一个估计量的数学期望是总体的参数，那么这个估计量无偏</p></li><li><p>有效性:<br>一个估计量同时也要准确，如果一个估计量的方差比另外一个的小，这前者估计量比后者有效</p></li><li><p>一致性（相合性）:<br>随着样本数的增加，估计量的值也应该越来越接近总体的参数(样本越多，估计越准确)</p></li></ol><h3 id="点估计"><a href="#点估计" class="headerlink" title="点估计"></a>点估计</h3><p>如果我们已经知道了总体的分布但不知道分布的参数，我们可以借助于样本来估计总体未知的参数。</p><ol><li><p>矩估计法</p><p>矩估计是一般人通常使用的估计方法，利用样本数据直接对总体的某些数字特征进行估计。<br>假设总体X服从某个分布，其$E(X)=μ$，$D(X)=σ^2$,有一些样本$X_1,X_2…X_n$独立，和X服从同一个分布。<br>有$E(\bar{X}) = \frac{E(X_1)+…+E(X_n)}{n} = μ$<br>$D(S^2) = σ^2$<br>$E(X^2) = μ+σ^2$</p></li><li><p>最大似然估计</p><p>要想求某个参数，还有一种思路就是通过概率，一般我们会构造一个概率$P(θ|X_1,X_2…X_n)$(这是个trick)，这个概率的直观意义就是在取到$X_1,…X_n$的情况下，取到θ值的概率。通过直观的理解，取到θ的概率越大越好，因为取到了θ，后面取到原本值才会更接近$X_1,…X_n$。所以<br>$P(θ|X_1,X_2…X_n)=\frac{P(θ,X_1,X_2…X_n)}{P(X_1,X_2…X_n)}=\frac{P(X_1,X_2…X_n|θ)P(θ)}{P(X_1,X_2…X_n)}$(分母各个样本值已经确定，是个常数，在这个问题下不用管)。然后我们默认，θ的各个取值都是平等的，也就是说θ的取值服从均匀分布，所以θ不管为多少，P(θ)都可以视为常数。最终，我们只需要关注$P(X_1,X_2…X_n|θ)$即可。而由于$X_1,X_2…X_n$独立，故$P(X_1,X_2…X_n|θ)=P(X_1|θ)P(X_2|θ)…P(X_n|θ)$。而当X为连续概率时，我们可以近似$P(X_1,X_2…X_n|θ)=f(X_1|θ)Δxf(X_2|θ)Δx…f(X_n|θ)Δx$。而Δx为常数，故最后的$L(θ) = f(X_1|θ)f(X_2|θ)…f(X_n|θ)$。当L(θ)取最大值的时候，此时的θ就是我们求的。当然当L(θ)不存在最大值的时候，我们只能通过别的方法求了。</p></li><li><p>最大后验估计</p><p>和前面的最大似然估计类似，但此处的θ不服从均匀分布。有可能是其他分布。</p></li></ol><h3 id="区间估计"><a href="#区间估计" class="headerlink" title="区间估计"></a>区间估计</h3><p>有了点估计的估计量远远不够，因为从样本得到的估计量并不是总体参数，估计值一定也会与现实有一定的距离，所以，我们还希望能预估总体参数最有可能落在的区间，并给出总体参数落在这个区间的可能性。这种形式的估计就叫区间估计。<br>假如给定一个α在(0,1)，从总体其中抽取多个样本$X_1,X_2,….,X_n$。确定两个统计量a,b。对参数θ</p><p>$P\{a&lt;θ&lt;b\} \ge 1-α$</p><p>则称随机区间(a,b)是θ的置信水平为1-α的置信区间。1-α的置信区间。</p><h4 id="置信区间的求法"><a href="#置信区间的求法" class="headerlink" title="置信区间的求法"></a>置信区间的求法</h4><ol><li>构造枢轴量$W=W(X_1,X_2,…X_n,θ)$，使W的分布不依赖θ和其他未知参数</li><li>对给定的置信水平1-α，确定2个常数使$P\{a&lt;W&lt;b\} \ge 1-α$，如果能得出等价的$P\{a’&lt;θ&lt;b’\} \ge 1-α$,则(a’,b’)是置信水平为1-α的置信区间。</li></ol><h4 id="总体平均值的区间估计"><a href="#总体平均值的区间估计" class="headerlink" title="总体平均值的区间估计"></a>总体平均值的区间估计</h4><p>大样本下，样本均值$\overline{X}\sim N(μ,\frac{σ^2}{n})$,所以能构造一个枢轴量$\frac{\overline{X}-μ}{\frac{σ}{\sqrt{n}}} \sim N(0,1)$。然后</p><p>$P\{|\frac{\overline{X}-μ}{\frac{σ}{\sqrt{n}}}|&lt;z\} = 1-α$</p><p>$P\{-z &lt; \frac{μ-\overline{X}}{\frac{σ}{√n}} &lt; z\} = 1-α$</p><p>$P\{\frac{μ-\overline{X}}{\frac{σ}{√n}} &lt; z\} - P\{\frac{μ-\overline{X}}{\frac{σ}{√n}} &lt; -z\}=<br>P\{\frac{μ-\overline{X}}{\frac{σ}{√n}} &lt; z\} - (1 - P\{\frac{μ-\overline{X}}{\frac{σ}{√n}} &lt; z\}) = 1-α$</p><p>$2P\{\frac{μ-\overline{X}}{\frac{σ}{√n}} &lt; z\} = 2 - α$</p><p>$P\{\frac{μ-\overline{X}}{\frac{σ}{√n}} &lt; z\} = 1 - \frac{α}{2}$</p><p>$P\{z &lt; \frac{μ-\overline{X}}{\frac{σ}{√n}} \} = \Phi(\frac{μ-\overline{X}}{\frac{σ}{√n}}) = \frac{α}{2}$</p><p>所以我们只要求出$1 - \frac{α}{2}$对应的$z_\frac{α}{2}$,此时其置信区间为$(\overline{X}\pm\frac{σ}{\sqrt{n}}*z_\frac{\alpha}{2})$</p><p>假如总体方差未知。可以考虑使用样本均值$S^2$,此时我们可以构造一个t分布的统计量$\frac{\frac{\overline{X}-μ}{\frac{σ}{√n}}}{\sqrt{\frac{S^2}{σ^2}}}\sim t(n-1)$<br>对统计量化简</p><p>$\frac{\frac{\overline{X}-μ}{\frac{σ}{√n}}}{\sqrt{\frac{S^2}{σ^2}}}=\frac{\overline{X}-μ}{\frac{S}{\sqrt{n}}}$<br>把上述情况原来的σ换成S，z分布换成t分布(t分布和z分布都是对称的)即可得到置信区间$(\overline{X}\pm\frac{S}{\sqrt{n}}*t_\frac{α}{2})$</p><h4 id="总体概率的区间估计"><a href="#总体概率的区间估计" class="headerlink" title="总体概率的区间估计"></a>总体概率的区间估计</h4><p>在大样本下，设X~B(N,p)为抽样条件下符合条件的个数,则抽样概率为$\frac{X}{N}$,而由于二项分布可以视为N个相互独立的0-1分布相加而来，故当N很大时，$P=\frac{X}{N}\sim N(p,\frac{p(1-p)}{N})$（其均值和方差可由性质直接求得）<br>构造z分布$\frac{P-p}{\sqrt{\frac{p(1-p)}{N}}} \sim N(0,1)$,将总体均值的$\overline{X}$换成$P$，$\frac{σ}{\sqrt{n}}$换成$\sqrt{\frac{p(1-p)}{N}}$可得p的置信区间$(P\pm\sqrt{\frac{p(1-p)}{N}}\times z_\frac{α}{2})$,但我们并不知道p是多少，而样本容量比较大，所以我们可以用P代替p，从而$(P\pm\sqrt{\frac{P(1-P)}{N}}\times z_\frac{α}{2})$</p><h4 id="总体方差的区间估计"><a href="#总体方差的区间估计" class="headerlink" title="总体方差的区间估计"></a>总体方差的区间估计</h4><p>假设一个正态分布简单抽出n个样本，有样本方差$s^2$，则可以构造一个统计量$\frac{(n-1)s^2}{σ^2} \sim \chi^2(n-1)$,则有</p><p>$P\{\chi^2_{1-\frac{α}{2}} \le \frac{(n-1)s^2}{σ^2} \le \chi^2_{\frac{α}{2}} \} = 1 - α$</p><p>$P\{\frac{(n-1)\chi^2_{\frac{α}{2}}}{s^2} \le σ^2 \le \frac{(n-1)\chi^2_{1-\frac{α}{2}}}{s^2} \} = 1 - α$</p><h2 id="假设检验"><a href="#假设检验" class="headerlink" title="假设检验"></a>假设检验</h2><p>假设我们蒙一个总体某个数字特征是否准确，但我们不能获取所有样本的所有特征，但我们可以通过获取的一部分样本，在给定的容错率判断我们的总体数字特征是否准确。这就是假设检验。</p><h2 id="方差分析"><a href="#方差分析" class="headerlink" title="方差分析"></a>方差分析</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 初等概率论 </tag>
            
            <tag> 统计学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性回归和logistics回归推导</title>
      <link href="2019/09/18/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%92%8Clogistics%E5%9B%9E%E5%BD%92%E6%8E%A8%E5%AF%BC/"/>
      <url>2019/09/18/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%92%8Clogistics%E5%9B%9E%E5%BD%92%E6%8E%A8%E5%AF%BC/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>日语单词集锦(1)</title>
      <link href="2019/09/16/%E6%97%A5%E8%AF%AD%E5%8D%95%E8%AF%8D%E9%9B%86%E9%94%A6-1/"/>
      <url>2019/09/16/%E6%97%A5%E8%AF%AD%E5%8D%95%E8%AF%8D%E9%9B%86%E9%94%A6-1/</url>
      
        <content type="html"><![CDATA[<div class="table-container"><table><thead><tr><th>单词</th><th>假名</th><th>意思</th></tr></thead><tbody><tr><td>凪ぐ</td><td>なぐ</td><td>【自】风平浪静</td></tr><tr><td>殴る</td><td>なぐる（凪ぐる）</td><td>【他1】殴打</td></tr><tr><td>慰める</td><td>なぐさめる（凪ぐ冷める）</td><td>【他】安慰</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>单词</th><th>假名</th><th>意思</th></tr></thead><tbody><tr><td>吹く</td><td>ふく</td><td>【自他】吹</td></tr><tr><td>服</td><td>ふく</td><td>衣服</td></tr><tr><td>膨らむ</td><td>ふくらむ（服らむ）</td><td>【自】鼓起，膨胀</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>单词</th><th>假名</th><th>意思</th></tr></thead><tbody><tr><td>歌（唄）</td><td>うた</td><td>歌</td></tr><tr><td>歌う</td><td>うたう</td></tr><tr><td>謡う</td><td>うたう</td></tr><tr><td>謳う</td><td>うたう</td></tr><tr><td></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>单词</th><th>假名</th><th>意思</th></tr></thead><tbody><tr><td>寂しい</td><td>さびしい</td><td>寂寞</td></tr><tr><td>錆びる</td><td>さびる</td><td>【自2】生锈（SB撸）</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>单词</th><th>假名</th><th>意思</th></tr></thead><tbody><tr><td>はた</td><td>はた</td><td>双棘石斑鱼</td></tr><tr><td>畑</td><td>はたけ</td><td>旱地</td></tr><tr><td>働く</td><td>はたらく</td><td>工作</td></tr><tr><td>叩く</td><td>はたく</td><td>敲打</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>单词</th><th>假名</th><th>意思</th></tr></thead><tbody><tr><td>降る</td><td>ふる</td><td>【自1】降下</td></tr><tr><td>振る</td><td>ふる</td><td>【他1】挥手</td></tr><tr><td>古い</td><td>ふるい</td><td>老旧的</td></tr><tr><td>震える</td><td>ふるえる</td><td>【自2】颤抖，震动</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>单词</th><th>假名</th><th>意思</th></tr></thead><tbody><tr><td>傘</td><td>かさ</td><td>伞</td></tr><tr><td>重なる</td><td>かさなる（傘なる）</td><td>【自1】重叠，重合</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>单词</th><th>假名</th><th>意思</th></tr></thead><tbody><tr><td>のぞ</td><td>のぞ</td><td>（但马方言）喉咙</td></tr><tr><td>望む</td><td>のぞむ</td><td>期望</td></tr><tr><td>臨む</td><td>のぞむ</td><td>面对</td></tr><tr><td>覗く</td><td>のぞく</td><td>窥探</td></tr><tr><td>除く</td><td>のぞく</td><td>除去</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>单词</th><th>假名</th><th>意思</th></tr></thead><tbody><tr><td>脱ぐ</td><td>ぬぐ</td><td>脱，摘掉</td></tr><tr><td>拭う</td><td>ぬぐう</td><td>擦掉，消除</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>单词</th><th>假名</th><th>意思</th></tr></thead><tbody><tr><td>幕</td><td>まく</td><td>帷幕</td></tr><tr><td>巻く</td><td>まく</td><td>卷上</td></tr><tr><td>撒く、蒔く、播く</td><td>まく</td><td>撒，播种</td></tr><tr><td>膜</td><td>まく</td><td>膜</td></tr><tr><td>枕</td><td>まくら</td><td>枕头</td></tr><tr><td>捲る</td><td>まくる</td><td>【他1】卷起，掀起</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>单词</th><th>假名</th><th>意思</th></tr></thead><tbody><tr><td>済む</td><td>すむ</td><td>结束</td></tr><tr><td>住む、棲む</td><td>すむ</td><td>居住，栖息</td></tr><tr><td>清む、澄む</td><td>すむ</td><td>清澈，清晰</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>单词</th><th>假名</th><th>意思</th></tr></thead><tbody><tr><td>だま</td><td>だま</td><td>小麦溶化后的残留物</td></tr><tr><td>騙す</td><td>だます</td><td>骗人</td></tr><tr><td>黙る</td><td>だまる</td><td>沉默，闭嘴</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>单词</th><th>假名</th><th>意思</th></tr></thead><tbody><tr><td>仄か</td><td>ほのか</td><td>朦胧，模糊</td></tr><tr><td>ほのぼの</td><td>ほのぼの</td><td>朦胧隐约</td></tr><tr><td>ほんのり</td><td>ほんのり</td><td>稍微</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>单词</th><th>假名</th><th>意思</th></tr></thead><tbody><tr><td>矛、戈</td><td>ほこ</td><td>矛，武器</td></tr><tr><td>頃</td><td>ころ</td><td>时候</td></tr><tr><td>転</td><td>ころ</td><td>滚子，滚轴</td></tr><tr><td>所</td><td>ところ</td><td>地方，住处</td></tr><tr><td>転ぶ</td><td>ころぶ</td><td>跌倒、滚动</td></tr><tr><td>殺す</td><td>ころす</td><td>杀人</td></tr><tr><td>綻ぶ</td><td>ほころぶ</td><td>绽放</td></tr><tr><td>綻びる</td><td>ほころびる</td><td>开绽</td></tr><tr><td>誇る</td><td>ほこる</td><td>自豪，引以为荣</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>单词</th><th>假名</th><th>意思</th></tr></thead><tbody><tr><td>端　</td><td>　つま　</td><td>　</td></tr><tr><td>尽く</td><td>ずく</td></tr><tr><td>躓く</td><td>つまずく</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>单词</th><th>假名</th><th>意思</th></tr></thead><tbody><tr><td>汗</td><td>あせ</td><td>汗</td></tr><tr><td>焦る</td><td>あせる</td><td>焦躁，急躁</td></tr><tr><td>褪せる</td><td>あせる</td><td>褪色，减弱</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>单词</th><th>假名</th><th>意思</th></tr></thead><tbody><tr><td>皺</td><td>しぼ（しわ）</td><td>褶皱</td></tr><tr><td>萎む、凋む</td><td>しぼむ</td><td>枯萎，凋谢</td></tr><tr><td>絞る、搾る</td><td>しぼる</td><td>拧，挤</td></tr></tbody></table></div>]]></content>
      
      
      
        <tags>
            
            <tag> 日语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言快速入门(新)</title>
      <link href="2019/09/15/C%E8%AF%AD%E8%A8%80%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
      <url>2019/09/15/C%E8%AF%AD%E8%A8%80%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文仅涉及C语言的语法，而不介绍具体的函数功能，函数功能可以看API手册上面的函数介绍。本文偏向于总结形式，所写的内容遵循的标准是C89/C99标准。此文在原来的基础上进行了修改。</p></blockquote><p><br><br>C语言是建立在汇编语言之上的中级语言，常常用于编写底层程序，嵌入式程序等</p><p>开始之前，你可能需要知道这些东西：</p><ol><li>内存，寄存器等存放的内容断电以后就会丢失，而且新的数据填入内存后，旧的内容就会被覆盖。</li><li>电脑是以二进制存储内容的（客观），冯诺依曼体系是数据和代码存储在一起的。也就是说，存储的东西是数据还是代码是人定义的，电脑本身并不知道某一段内容是数据还是代码。（哈佛结构则将数据和代码分开）</li><li>存储的数据超过设定的容量就会发生溢出，可能会丢失一部分数据。</li></ol><p>在C语言中,单独一个语句的结束标志是西文的分号;不管你的语句是放在了一行还是单独另起一行，但是，如果是花括号构成的复合语句（准确来说整体的语句结束时的末尾为右花括号｝），一般情况下分号可以省略    </p><pre class=" language-lang-c"><code class="language-lang-c">int a;&#123;    int b = a++;    b += a;&#125;</code></pre><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>标识符是开发者编程的时候用的名字，C语言对标识符的命名有以下规定</p><ul><li>不能和当前的关键词同名,同一个作用域标识符不能重名</li><li>标识符大小写是有区别的</li><li>开头只能是字母和_,后面可以是字母,数字和_<br>满足以上条件，命名是自由的，但是好的标识符可为以后的开发维护带来诸多方便。这里介绍几个常用方法</li></ul><h3 id="小驼峰命令法"><a href="#小驼峰命令法" class="headerlink" title="小驼峰命令法"></a>小驼峰命令法</h3><p>由其术语能联想到，它混合使用大小写字母来构成变量和函数的名字。许多新的函数库和Windows命令中，使用得当相多。不过实际工程多用于命名变量。</p><pre><code>isEnabledschoolName</code></pre><h3 id="大驼峰命令法"><a href="#大驼峰命令法" class="headerlink" title="大驼峰命令法"></a>大驼峰命令法</h3><p>和小驼峰不同的是，大驼峰的首字母大写，实际多用于类型名</p><pre><code>VelocityResponseWriterInputStream</code></pre><h3 id="匈牙利命名法-已删除"><a href="#匈牙利命名法-已删除" class="headerlink" title="匈牙利命名法(已删除)"></a>匈牙利命名法(已删除)</h3><p>实际项目没人用，有兴趣可自查</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>char（character）：表示一个字符的编码。在被用于进行数学运算或者位运算的时候会被视为普通的整数类型，而在其他的情况则会与其他的整数类型区别对待，比如在输出成文字的时候系统会按照字符的某一种编码（ASCII码，GB2312，utf-8，big5码等）根据其值寻找对应的文字，然后按照这个文字的显示方式（字体）和各种参数显示或者输出。通常在编译器的设定里为1B</p><p>int（integer）：常用的有符号整数类型(有符号的整数使用补码存储)，能够表示比较大的整数，参与数学运算或者位运算。而short类型，long类型和int类型的区别是存储的数值范围是long&gt;=int&gt;=short&gt;=char</p><p>unsigned：整数类型的修饰符，表示整数变量没有负数，不用考虑数学的符号，在表示unsigned int时候，int可以省略。</p><p>注：C语言没有专门表示逻辑的类型和常量，用整数表示逻辑真假时，用0表示假，非零表示真。逻辑转换为整数时，真为1，假为0。在C99里，引入了一个新的数据类型_Bool型专门表示逻辑类型，虽然实际上它也是属于整数类型，但只能为0或1，true或者false</p><p>浮点数类型能表示一定范围和精度带符号的小数，有double和float。表示范围的大小long double&gt;=double&gt;=float，它们的存储方式请自行搜索。</p><p>void：特殊的类型，它表示什么类型都不是。一般用在函数的声明和定义表示不返回数据。</p><p>声明变量的格式是     数据类型 标识符;</p><blockquote><p>在C89标准里变量定义必须在前面，而C99标准可以把变量的定义放在任意位置</p></blockquote><p>一般也可以在定义的时候赋予初值,其形式是 数据类型 标识符=值;</p><pre class=" language-lang-c"><code class="language-lang-c">int a=1,b,c;double c,d;</code></pre><p>这就是变量的初始化，但是变量的初始化和赋值是不一样的。不赋值则是随机数</p><blockquote><p>变量定义的实质是向系统申请一块内存区域，系统找到一块合适的地方再进行简单的标记（比如登记给定的类型，放入指定的值）。（就像是自己提出要租什么类型的房子，房东找到合适的房子给你，然后身份证进行简单的登记，房子里至于是什么样房东不管，这也解释了为什么初始化一个变量以后里面的内容是随机的。 严格来说，其数值不算随机，因为可以跟踪上一次程序使用这一块内存的操作来推断，不过没人这么干）</p></blockquote><p>一般情况下，如果程序发现变量被赋予值的类型和它自身的不相同，会先尝试隐式转换（一般是占用空间小的类型往占用空间大的类型转换），就是能简单的去去小数，把存储的位数进行调整。若无法进行调整，需要强制进行类型转换，格式为（数据类型） 最小单位的表达式</p><h2 id="变量的修饰关键词"><a href="#变量的修饰关键词" class="headerlink" title="变量的修饰关键词"></a>变量的修饰关键词</h2><p>const：用来声明变量位于只读内存区域，也就是说只可读取其存储的值但不能修改，常常用于声明常量，也用来写函数时将不需要修改值的变量设置成const防止显式的意外修改。</p><p>auto：默认的关键词，用来声明局部变量，生命周期一般是在变量所在的范围最小的花括号内（可以把整个源代码文件的范围当做一个很大的无名花括号，定义在程序里的全局变量一般初值全为二进制的0），在生命周期外变量会被销毁（可省略）</p><blockquote><p>由于局部变量实在太常用，auto很少用来定义局部变量，所以在C11标准中auto变成了根据给定的初值自动设置变量的类型的关键词。</p></blockquote><p>register：声明变量在寄存器中存储，它是高速小容量靠近CPU的储存单元，并且数量有限，有些的还有特殊的用途，所以register只是一个建议，而且由于寄存器是一种单独离散的特殊单元，不能用&amp;取地址（寄存器没有地址）</p><p>static：程序运行时声明变量的所在的内存一直会被保留到程序结束。被其修饰的变量所在的内存区域一般全是二进制的</p><p>extern：表示此全局变量是从别的源代码文件定义的。</p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>顾名思义就是不变的量，数学里的π永远等于3.1415926535…，e等于2.718281828459…，f（x）=x<sup>2</sup>+2x+1中的数2,1。类似的，代码里直接出现的数，和符号代替的数就是常量。在c语言中基本类型的数值都有表示方法</p><p>在整型常量中，有二进制，十进制，八进制和十六进制表示方法，十进制就跟正常生活数的表示方法一样。八进制要在八进制表示的数前面加一个0，十六进制要在前面加0x或者0X，二进制要在数的前面加0b，默认情况下，十进制表示的数都会被认为是int类型，如果想表示无符号类型就要在数的后面加一个u，长整型要在数的后面加l或者L，长无符号整型在数的后面加lu，长长整型要加ll。浮点数一般是我们生活常用的表达。默认是double类型，要是表示float类型，需要在数的后面加一个f。还有一种则是科学计数法的表示方法。用 底数e整数表示，整数正负均可。</p><pre class=" language-lang-c"><code class="language-lang-c">-1000xfff0o4567120b1011154L30U65598LU5466778ll12.343.14159f1.1e-3</code></pre><p>字符型常量用一对单引号包含一个字符</p><pre class=" language-lang-c"><code class="language-lang-c">'c' '1'</code></pre><p>字符串（字符数组常量）是用一对双引号包含字符串。是特殊的字符数组常量的表示方法。我们规定，字符串的结束标志是‘\0’。</p><pre class=" language-lang-c"><code class="language-lang-c">"c++""我太难了"</code></pre><h2 id="基本运算符号"><a href="#基本运算符号" class="headerlink" title="基本运算符号"></a>基本运算符号</h2><p>赋值符号= :运算级别倒数第二的运算符号 它将右边的值赋值给左边，不难理解，赋值符号左边只能是可以写入的存储单元，所以这样的存储单元又叫左值（lvalue），赋值表达式返回的值是等号右边得到的值。</p><pre class=" language-lang-c"><code class="language-lang-c">a=1; //a的内容是1，同时这个表达式返回的值是1</code></pre><p>逗号, :运算级别最低的符号，主要是以逗号为分界点，从左逐一执行运算操作得到数值，整个表达式最后的结果是最右边得到的值。</p><p>加号+ 减号- 乘号* 除号/ 和数学意义上的运算是一样的，他们相对的运算顺序也和数学的四则运算是一样的。而求余符号%是计算整数之间整除以后的余数。</p><pre class=" language-lang-c"><code class="language-lang-c">1+2,3*4,5-6,13/2; //从左到右分别是3,12,-1,6，最后结果是6</code></pre><p>位左移&lt;&lt;是把一个数当做二进制进行左移，左边移出的二进制位舍弃，右边移进来的二进制位用0填充。</p><pre class=" language-lang-c"><code class="language-lang-c">6<<2;//表示将6这个int类型左移两位，得到24.</code></pre><p>位右移&gt;&gt;是把一个数当做二进制进行右移，右边移出的二进制位舍弃，左边移进来的二进制位用0填充。</p><pre class=" language-lang-c"><code class="language-lang-c">6>>2;//表示将6这个int类型右移两位，得到1.</code></pre><p>位与&amp;:把两个数的二进制逐个进行与运算。<br>位或|:把两个数的二进制逐个进行或运算。<br>位取反~:把一个数的二进制进行取反运算<br>异或^:把2个数的二进制进行异或运算<br>取地址符号&amp;:得到一个变量在内存中的地址。（这里的地址是个相对概念，在系统里给程序的内存地址是个相对地址）<br><em>:寻址符号是根据内存地址来指向一个内存空间，eg </em>p=2;将2赋给p里的内存地址指向的内存单位。<br>成员运算符.是引出整体里的成员，比如k.name就是调出k里的小成员name<br>-&gt;:指向成员运算符，就是通过其将内存地址直接指向成员而不是整体</p><pre class=" language-lang-c"><code class="language-lang-c">p->name;//p这个指针通过此运算符直接指向那个内存单位的成员name</code></pre><p>自增++是指存储单位的值加一个单位的数值，而自减—是指存储单位的值减一个单位的数值。他们在前面表示先进行运算在取值，在后面表示先取值在进行运算（有自增自减运算是因为汇编有专门的指令inc，dec）</p><p>复合赋值符号是先计算等号右边的值，在把左边的值和右边计算的结果进行运算赋值给左值。（有复合复制符号是因为汇编里像add eax，ebp都是把左边的值和右边的值进行运算并把结果存入左边的存储单元）</p><pre class=" language-lang-c"><code class="language-lang-c">a += 2;//就是a和2相加，在把结果给a。</code></pre><p>sizeof()是一个特殊的运算符，它是计算一个类型所占的字节数，用法是sizeof(变量或者数据类型)</p><pre class=" language-lang-c"><code class="language-lang-c">sizeof(int);//编译器一般会返回4</code></pre><p>括号()是将括号里的表达式强制提到最高运算的优先级，相当于数学运算里括号的作用</p><h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><p>大于&gt;，小于&lt;，不大于&lt;=，不小于&gt;=，不等于!=，等于==表示的意义和数学一样，只不过它返回的是逻辑上的真或假</p><p>逻辑与&amp;&amp;，逻辑或||，逻辑非!和数学里的用法是一样的</p><blockquote><p>当一个逻辑运算只计算了左边得到的逻辑结果就能判定整个逻辑运算的结果时，会跳过右边的逻辑运算。</p></blockquote><p>条件运算符?: :计算问号左边的逻辑真假，如果为真结果就是冒号左边的结果，为假是冒号右边的结果。</p><h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><h3 id="如果语句"><a href="#如果语句" class="headerlink" title="如果语句"></a>如果语句</h3><pre class=" language-lang-c"><code class="language-lang-c">if(返回整数的表达式) 语句1 [else 语句2]</code></pre><p>此语句先计算返回整数的表达式，如果是逻辑上的真，就执行语句1，如果是假就执行语句2，如果没有逻辑为假的操作，方括号里的语句可以不写。</p><h3 id="先判断当循环语句"><a href="#先判断当循环语句" class="headerlink" title="先判断当循环语句"></a>先判断当循环语句</h3><pre class=" language-lang-c"><code class="language-lang-c">while(返回整数的表达式) 语句</code></pre><p>此语句先判断返回整数的表达式，为真就执行循环语句，在进入下一次循环判断，为假就结束循环不执行语句</p><h3 id="后判断循环语句"><a href="#后判断循环语句" class="headerlink" title="后判断循环语句"></a>后判断循环语句</h3><pre class=" language-lang-c"><code class="language-lang-c">do 循环语句 while(返回整数类型的表达式)</code></pre><p>这个先执行循环语句，然后在判断返回整数的表达式，为真就继续进行循环，为假就结束循环。</p><h3 id="计次循环语句"><a href="#计次循环语句" class="headerlink" title="计次循环语句"></a>计次循环语句</h3><pre class=" language-lang-c"><code class="language-lang-c">    for(语句a;返回整数的表达式b;语句c) 循环语句d</code></pre><p>首先执行语句a，然后计算返回整数的表达式b，如果为逻辑上的真就执行循环语句d，最后在执行语句c进入下一个循环判断;如果为假就结束循环</p><blockquote><p>循环语句里可以使用break来跳出循环体，也可以使用continue来直接进入下一次的循环。流程控制语句可以使用花括号的复合语句</p></blockquote><p>栗子：</p><pre class=" language-lang-c"><code class="language-lang-c">if(a==0) a=1; else a=2;if(a==3) &#123;    a=3;    printf("a is 3");&#125;else &#123;    a=4;    printf("a is not 3");&#125;</code></pre><h3 id="选择语句格式"><a href="#选择语句格式" class="headerlink" title="选择语句格式"></a>选择语句格式</h3><pre class=" language-lang-c"><code class="language-lang-c">switch(返回整数的表达式)&#123;case 整数常量a:语句a1;语句a2;...语句an;case 整数常量b:语句b1;语句b2;...语句bn;...case 整数常量n:语句n1;...语句nn;[default:]语句1;语句2;...语句n;&#125;</code></pre><p>此语句是先计算返回整数的表达式，然后进入花括号按从上到下的顺序与case后的整数常量进行判断，遇到相等的整数常量就在此标签开始执行后面的语句一直执行到底，如果遇到了半天都没有遇到，程序会从default:标签开始执行语句，当然，也可以中间使用break语句跳出这个花括号的复合语句。</p><pre class=" language-lang-c"><code class="language-lang-c">switch (a)&#123;        default:printf("error\n");        case 1:printf("Monday\n");        case 2:printf("Tuesday\n");        case 3:printf("Wednesday\n");        case 4:printf("Thursday\n");        case 5:printf("Friday\n");        break;        case 6:printf("Saturday\n");        case 7:printf("Sunday\n");    &#125;</code></pre><p>如果a等于8，程序会从default:标签开始执行，输出结果为</p><pre><code>errorMondayTuesdayWednesdayThursdayFriday</code></pre><h2 id="函数（构成C语言程序最小的单元）"><a href="#函数（构成C语言程序最小的单元）" class="headerlink" title="函数（构成C语言程序最小的单元）"></a>函数（构成C语言程序最小的单元）</h2><p>编程的函数和数学里的函数类似，只不过数学里的函数仅仅只是输入数（可以是一个数或者几个数）通过一定的方法得到另一个数。而编程里的函数不止可以做数学计算，还可以干其他的事，可以没有输入，也可以有好几个（就行你给一个人发出命令，可以让他去写一篇文章，可以规定一些要求，也可以什么也不要求，最后得到的东西就是写好的文章）</p><h3 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h3><pre class=" language-lang-c"><code class="language-lang-c">数据类型 函数标识符([数据类型 参数标识符1，数据类型 参数标识符2...,数据类型 参数标识符n]);</code></pre><p>其中声明的参数标识符可以省略</p><h3 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h3><pre class=" language-lang-c"><code class="language-lang-c">数据类型 函数标识符([数据类型 参数标识符1，数据类型 参数标识符2...,数据类型 参数标识符n])&#123;语句1...语句n&#125;</code></pre><p>其中函数不能嵌套定义，也就是说不能在一个函数的语句里不能在定义一个函数。实际上，那些参数也是函数里的局部变量，只是摆在了括号里等待数据的传入。而且在c语言里，在调用函数时，传入参数的个数和类型都要正确。</p><h3 id="函数的调用形式"><a href="#函数的调用形式" class="headerlink" title="函数的调用形式"></a>函数的调用形式</h3><p>定义的函数标识符（传入的参数1,……，传入的参数n）但调用的前提是前面必须有函数的定义或者声明，否则会出现错误<br>以上的一些规定其实可以和数学的函数类比，数学的函数哪里学过嵌套定义另外的函数，但是我们可以在前面设一个函数，然后在另外一个函数调用前面设好的函数，而且数学里前面没有设好的函数，后面的函数不能无中生有调用前面没有的函数（就像你之前如果不知道写文章是什么意思，老板命令你写文章，你不知道怎么回事。）</p><p>在c语言中，整个程序的入口函数名为main，入口函数的定义为:</p><pre class=" language-lang-c"><code class="language-lang-c">int main()&#123;&#125;和int main(int argc，char**argv)&#123;&#125;</code></pre><h2 id="其他的类型"><a href="#其他的类型" class="headerlink" title="其他的类型"></a>其他的类型</h2><h3 id="数组类型array"><a href="#数组类型array" class="headerlink" title="数组类型array"></a>数组类型array</h3><p>数组类型是为了方便解决一些问题，在内存的排列是连续的。表示方法如下:</p><pre class=" language-lang-c"><code class="language-lang-c">数据类型 []</code></pre><p>数组变量初始化一般有如下几个方法</p><pre class=" language-lang-c"><code class="language-lang-c">int a[3]=&#123;1,2,3&#125;int a[]=&#123;1,2,3,4,5&#125;int a[10]=&#123;1,2,3,4,5,6&#125;</code></pre><p>但是数组在定义后不能直接整体赋值，也就是说，像a=的赋值将会导致错误，这是因为数组名表示的是指针常量，而不是变量，只能间接通过内存复制来间接赋值。</p><p>数组变量引用的下标一定是有符号的整数类型（无符号的将会导致程序崩溃）</p><h3 id="指针pointer"><a href="#指针pointer" class="headerlink" title="指针pointer"></a>指针pointer</h3><p>指针是存储内存地址的存储单元，它的作用是方便对某一块内存进行操作（比如对另一块传入的变量进行操作，对申请到的无名内存进行操作等）其基本形式是 数据类型 ＊，而在利用指针的时候，指针的使用方法是 ＊变量标识符，整体就变成了指向目标类型的内存区域了。但是，指针在进行增减运算时，是以数据类型存储大小为单位的</p><pre class=" language-lang-c"><code class="language-lang-c">int a,p=&a;p++;</code></pre><p>这时候p指针自增了sizeof(int)单位的数值。</p><p>还有一种叫做函数指针的东西，就是指向一个特定格式函数的指针。长得像如下形式</p><pre class=" language-lang-c"><code class="language-lang-c">返回形式 (*指针名)(参数列表)</code></pre><p>函数指针可以直接当成函数来调用指针指向的函数。</p><p>举个🌰</p><pre class=" language-lang-c"><code class="language-lang-c">int foo(int a,int b)&#123;    return a-b;&#125;int main()&#123;    int (*compare)(int a,int b) = foo;    compare = &foo;    (*compare)(1,2);    compare(1,2);&#125;</code></pre><h3 id="结构体struct"><a href="#结构体struct" class="headerlink" title="结构体struct"></a>结构体struct</h3><p>结构体是指为了方便管理数据专门自己设置的数据类型，不管有名还是无名它都会开辟内存空间，定义方式：</p><pre class=" language-lang-c"><code class="language-lang-c">struct 标识符 &#123;数据类型1 成员标识符1...数据类型n 成员标识符n&#125;;</code></pre><p>这里自定义结构体名可以省略，但是这里的分号不可以省略，因为定义的整体就是一个数据类型</p><pre class=" language-lang-c"><code class="language-lang-c">struct student &#123;    unsigned number;    unsigned age;    unsigned score;&#125; function()&#123;&#125;</code></pre><p>这里的函数的返回类型为结构体student</p><p>使用定义的结构体类型的方法是struct 已定义的结构体名</p><h3 id="枚举enum"><a href="#枚举enum" class="headerlink" title="枚举enum"></a>枚举enum</h3><p>在c语言是一种构造类型，用于声明一组命名的常数。其基本定义格式是 </p><pre class=" language-lang-c"><code class="language-lang-c">enum 标识符&#123;成员标识符1[=整数值],...,成员标识符n[=整数]&#125;</code></pre><p>如果成员1没有给出整数，默认为0，之后的元素以1递增，成员名不能重名。</p><p>使用定义的枚举类型为</p><pre class=" language-lang-c"><code class="language-lang-c">enum 定义的标识符</code></pre><h3 id="共同体（联合，union）"><a href="#共同体（联合，union）" class="headerlink" title="共同体（联合，union）"></a>共同体（联合，union）</h3><p>一种构造类型，几个成员共用一个内存空间，最后的大小取决于占用内存最大的成员，其基本定义形式是</p><pre class=" language-lang-c"><code class="language-lang-c">union 标识符&#123;数据类型 成员标识符1数据类型 成员标识符2.....数据类型 成员标识符n&#125;;</code></pre><p>使用已定义的共同体类型为 </p><pre class=" language-lang-c"><code class="language-lang-c">union 已定义的标识符</code></pre><h2 id="预处理指令"><a href="#预处理指令" class="headerlink" title="预处理指令"></a>预处理指令</h2><p>所有的预处理指令都是在程序编译以前就执行的指令,且前面都是##开头。</p><h1 id="include指令是包含指令，在编译以前将给定的文件包含进去，有两种形式-include-lt-文件名-gt-和-include-“文件名”，其中前一个是让预处理程序到预定义的缺省路径下寻找文件，后一种是让其先在源代码文件的当前目录下寻找文件，然后在默认路径下找。"><a href="#include指令是包含指令，在编译以前将给定的文件包含进去，有两种形式-include-lt-文件名-gt-和-include-“文件名”，其中前一个是让预处理程序到预定义的缺省路径下寻找文件，后一种是让其先在源代码文件的当前目录下寻找文件，然后在默认路径下找。" class="headerlink" title="include指令是包含指令，在编译以前将给定的文件包含进去，有两种形式#include &lt;文件名&gt;和#include “文件名”，其中前一个是让预处理程序到预定义的缺省路径下寻找文件，后一种是让其先在源代码文件的当前目录下寻找文件，然后在默认路径下找。"></a>include指令是包含指令，在编译以前将给定的文件包含进去，有两种形式#include &lt;文件名&gt;和#include “文件名”，其中前一个是让预处理程序到预定义的缺省路径下寻找文件，后一种是让其先在源代码文件的当前目录下寻找文件，然后在默认路径下找。</h1><h1 id="define-目标1-结果1，是讲非双引号之外的内容进行简单的文本替换（结果1可以有多个空格），常见的形式为"><a href="#define-目标1-结果1，是讲非双引号之外的内容进行简单的文本替换（结果1可以有多个空格），常见的形式为" class="headerlink" title="define 目标1 结果1，是讲非双引号之外的内容进行简单的文本替换（结果1可以有多个空格），常见的形式为"></a>define 目标1 结果1，是讲非双引号之外的内容进行简单的文本替换（结果1可以有多个空格），常见的形式为</h1><pre class=" language-lang-c"><code class="language-lang-c">#define text “Hello world”</code></pre><p>如果定义了函数的替换，函数的参数会在代码里简单的替换成目标指令</p><p>目标中的 #表示将参数变成字符串，##是用于连接两个字符串的</p><pre class=" language-lang-c"><code class="language-lang-c">#define M(x,y) x*yM(3+5,2+7);//相当于3+5*2+7,结果为20#define paster( n ) printf( "token " #n" = %d\n ", token##n )paster(9);</code></pre><p>相当于</p><pre class=" language-lang-c"><code class="language-lang-c">printf("token 9 = %d\n",token9);</code></pre><p>当然，如果替换的内容很长，又不想写在一行上，就可以在一行的末尾用\结尾，然后另起一行继续写</p><pre class=" language-lang-c"><code class="language-lang-c">#define menutext "1.scanf()\n\2.printf()\n\3.exit\n"</code></pre><p>如果想取消前面的宏定义可以使用##undef 目标1</p><h1 id="if预处理是一个和类似于if语句的预处理指令，如果为真就执行-if和-else或者-elif之间的语句，否则就会执行后面的-else或者进行-elif的判断（else-if的省略）"><a href="#if预处理是一个和类似于if语句的预处理指令，如果为真就执行-if和-else或者-elif之间的语句，否则就会执行后面的-else或者进行-elif的判断（else-if的省略）" class="headerlink" title="if预处理是一个和类似于if语句的预处理指令，如果为真就执行#if和#else或者#elif之间的语句，否则就会执行后面的#else或者进行#elif的判断（else if的省略）"></a>if预处理是一个和类似于if语句的预处理指令，如果为真就执行#if和#else或者#elif之间的语句，否则就会执行后面的#else或者进行#elif的判断（else if的省略）</h1><h1 id="ifdef和-ifndef比较特殊，它是判断前面有没有-define定义的标识符执行方式类似于-if"><a href="#ifdef和-ifndef比较特殊，它是判断前面有没有-define定义的标识符执行方式类似于-if" class="headerlink" title="ifdef和#ifndef比较特殊，它是判断前面有没有#define定义的标识符执行方式类似于#if"></a>ifdef和#ifndef比较特殊，它是判断前面有没有#define定义的标识符执行方式类似于#if</h1><h1 id="endif是结束前面预处理指令的判断"><a href="#endif是结束前面预处理指令的判断" class="headerlink" title="endif是结束前面预处理指令的判断"></a>endif是结束前面预处理指令的判断</h1><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>typedef关键词是为一个数据类型其另外一个名字，并不是生成了一个新的类型，形式是typedef 数据类型 别名比如</p><pre class=" language-lang-c"><code class="language-lang-c">typedef struct &#123;int a;&#125;ok;typedef unsigned long DWORD;</code></pre><h2 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h2><p>goto语句实际上是汇编语言的jmp语句，实现无条件跳转指定标签的功能，用法如下goto 标签标识符</p><pre class=" language-lang-c"><code class="language-lang-c">loop: if(getchar()!='\n')&#123;n++;goto loop;&#125;</code></pre><p>等价于下面的x86汇编指令</p><pre class=" language-lang-x86asm"><code class="language-lang-x86asm">loop: CALL getcharCMP AX,'\n'JZ outINC nJMP loopout:...</code></pre><p>由于后来结构化编程的思想出现，goto语句用的很少了</p><h2 id="个人其他的一点见解"><a href="#个人其他的一点见解" class="headerlink" title="个人其他的一点见解"></a>个人其他的一点见解</h2><p>其实数组的定义应该是类似于Java标准的定义</p><pre class=" language-lang-c"><code class="language-lang-c">int [2] a=&#123;1,2&#125;;//实际这样写C语言会报错</code></pre><p>而且严格意义上来说，a指向的类型是int [2]类型，&amp;a[0]指向的类型是int类型，除非是作为sizeof或者单目&amp;操作符的操作数，C语言都将数组名弱化为基本的类型只是方便我们的处理。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
