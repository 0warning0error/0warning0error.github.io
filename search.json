[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "你好，这个博客是使用的Quarto编写并发布的，最开始想找一个炫酷的界面作为我的博客， astro.build是当时我想尝试的框架，但因为没时间钻研前端框架，最后选择了使用Quarto。"
  },
  {
    "objectID": "posts/convert-recursion-into-iteration/index.html",
    "href": "posts/convert-recursion-into-iteration/index.html",
    "title": "将递归转成迭代",
    "section": "",
    "text": "函数的递归调用是简单易懂的编码方式，在某些问题上，函数递归可以提供更为简洁的代码实现和更为直观的阅读理解，比如说我们很熟悉的树形结构的遍历。\n然而，当函数调用的层数过多的时候，就可能导致常见的栈溢出，这是因为栈空间一般是有严格的大小限制。虽然我们可以通过配置参数来调整程序的栈空间大小，但只是杯水车薪，无助于解决根本问题。\n我们从另一个角度看待问题：操作系统调用函数会保存栈信息（比如函数返回后的下一条指令所在的位置、局部变量等），在其中隐式地含有每一个函数调用的状态，函数通过查看这个状态来决定是否已满足停止条件，所以我们自然而然地想到用栈数据结构来模拟函数递归的过程。\n结合状态机的知识，将递归版本的函数改为迭代版本的函数的思想不难分析，假如我们有如下递归版本的函数：\nvoid func(...args){\n    // 局部变量列表(函数参数也是局部变量的一部分)\n    doSomething();\n    \n    // 在某处出现了递归调用\n    func(...args1);\n}\n然后我们可以设置一个状态结构体保存递归版本被调用时的函数信息，一部分保存当前调用栈的函数变量信息，最后保存运行时候的位置。假如函数有返回值，可以用一个变量存储返回值：\nenum Loc{\n    START;\n    FIRST;\n    SECOND;\n    THIRD;\n    // ...等等位置信息\n};\nstruct State{\n    //局部参数列表\n    struct Info context;\n    // 运行时候的位置\n    enum Loc location;\n};\nvoid func(...args){\n    stack&lt;State&gt; s;\n    State init_state = {}; //设置初始的状态。\n    s.push(std::move(init_state));\n    while(!s.empty()){\n        State & cnt_state = s.top();\n        switch(cnt_state.location){\n            case START:\n                doSomething();\n            case FIRST:\n                cnt_state.location = SECOND;\n                cnt_state.context = ...;\n                State new_state = {...};\n                s.push(new_state);\n                continue;\n            //....\n        }\n    }\n}\n我们以leetcode的中序遍历为例子，不难写出下面的递归版本：\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector&lt;int&gt; inorderTraversal(TreeNode* root) {\n        vector&lt;int&gt; res;\n        if(root == nullptr){\n            return res;\n        }\n        vector&lt;int&gt; && left = inorderTraversal(root -&gt; left);\n        res.insert(res.end(),left.begin(),left.end());\n        res.push_back(root -&gt; val);\n\n        vector&lt;int&gt; && right = inorderTraversal(root -&gt; right);\n        res.insert(res.end(),right.begin(),right.end());\n        return res;\n    }\n};\n中序遍历有2个递归调用点：一个是访问左子树的时候，另一个是读取中间的节点后的右子树的时候；和一个本身调用点。 而因为整个函数比较重要的局部变量是 参数root，所以结构体只需要保存一个参数。 最后迭代版本的中序遍历如下\nenum Loc{\n    START,           // 初始状态，表示节点刚被访问\n    VISITED_LEFT,    // 左子节点已访问\n    VISITED_MIDDLE,  // 中间节点已访问\n};\n\nstruct State {\n    TreeNode *node;  // 当前节点\n    Loc location;    // 当前节点的访问状态\n};\n\nclass Solution {\npublic:\n    vector&lt;int&gt; inorderTraversal(TreeNode* root) {\n        vector&lt;int&gt; result;\n        stack&lt;State&gt; s;\n\n        // 辅助函数，将节点及其状态压入栈中\n        auto pushState = [&](TreeNode *node) {\n            s.push({node, START});\n        };\n\n        // 初始条件，根节点不为空时压入栈\n        if (root != nullptr) {\n            pushState(root);\n        }\n\n        // 模拟递归调用的循环\n        while (!s.empty()) {\n            State &cnt_state = s.top(); // 获取栈顶元素，模拟当前函数调用的参数和局部变量\n\n            switch (cnt_state.location) {\n                case START:\n                    // 首次访问节点，先访问左子树\n                    if (cnt_state.node-&gt;left != nullptr) {\n                        cnt_state.location = VISITED_LEFT;  // 修改状态为已访问左子节点\n                        pushState(cnt_state.node-&gt;left);   // 将左子节点压入栈\n                        continue;                          // 提前结束本次循环\n                    }\n                case VISITED_LEFT:\n                    // 左子树访问完毕，访问当前节点\n                    result.push_back(cnt_state.node-&gt;val); // 将节点值加入结果\n                    cnt_state.location = VISITED_MIDDLE;   // 修改状态为已访问中间节点\n                    // 访问右子树\n                    if (cnt_state.node-&gt;right != nullptr) {\n                        pushState(cnt_state.node-&gt;right);  // 将右子节点压入栈\n                        continue;\n                    }\n                case VISITED_MIDDLE:\n                    // 当前节点及其左右子树都已访问完毕，返回出栈\n                    s.pop();\n                    continue;\n            }\n        }\n\n        return result;\n    }\n};"
  },
  {
    "objectID": "posts/trying-to-intergrate-z3-into-typst/index.html",
    "href": "posts/trying-to-intergrate-z3-into-typst/index.html",
    "title": "尝试将z3集成进typst",
    "section": "",
    "text": "Z3求解器是一个微软开源的定理证明器，高效好用。有一天我突发奇想，想将其集成进typst中，因为理论上来说定理证明器涉及不到其他环境的交互，但我想的太简单了。最终我放弃了，写此文章记录探索的过程。\n把z3集成进typst最简单的方法：就是编译出纯WASM文件，WASM作为插件。然后用typ文件包装好这个WASM文件，暴露出优雅的接口。\n最开始我的想法是直接写Rust代码调用Z3，但发现Z3-sys的库本质上是调用的编译好的共享库，遂放弃纯Rust方法。\n我开始阅读Z3的文档，然而并没有直接编译成WASM的教程，但却有提供JavaScript的NPM包，也有WASM的bindings。我顺藤摸瓜找到了src/api/js/scripts/build-wasm.ts 这么一个文件，内容如下：\n从这些代码我可以看到首先使用emconfigure配置编译环境，然后用emmake编译出静态库。这些代码刚好给了我启发——我可以先编译出适配的静态库（因为Z3也提供了C语言接口），然后用Rust FFI 调用必要的C接口，结合 这个项目 方便的包装，编译出适配typst的wasm插件。 理想是美好的，现实是骨感的。"
  },
  {
    "objectID": "posts/trying-to-intergrate-z3-into-typst/index.html#第一次尝试",
    "href": "posts/trying-to-intergrate-z3-into-typst/index.html#第一次尝试",
    "title": "尝试将z3集成进typst",
    "section": "第一次尝试",
    "text": "第一次尝试\n于是，我先按照上面的ts代码，配置好3.1.15版本的emsdk（复现编译器的版本），编译出libz3.a 的静态库。\nemconfigure python scripts/mk_make.py --staticlib --single-threaded --arm64=false\ncd build\nemmake make -j$(nproc) libz3.a\n就这样，一个z3的静态库出炉了，当我欣喜若狂的写好Rust的适配代码调用静态库、链接最后编译出wasm文件、用typst调用wasm的时候，意外发生了——环境不支持SIMD指令。\n原来是typst使用的wasmi库不支持SIMD指令。既然这样，那我就将SIMD的选项去掉。"
  },
  {
    "objectID": "posts/trying-to-intergrate-z3-into-typst/index.html#第二次尝试",
    "href": "posts/trying-to-intergrate-z3-into-typst/index.html#第二次尝试",
    "title": "尝试将z3集成进typst",
    "section": "第二次尝试",
    "text": "第二次尝试\n因为z3的配置选项并不支持直接屏蔽SIMD选项， 我只能直接对config.mk文件动手，修改后内容如下\nCXXFLAGS= -D_MP_INTERNAL -DNDEBUG -D_EXTERNAL_RELEASE  -std=c++17 -fvisibility=hidden -fvisibility-inlines-hidden -c -DSINGLE_THREAD -O3 -mno-simd128 -fno-tree-vectorize -fPIC -flto\nCFLAGS= -D_MP_INTERNAL -DNDEBUG -D_EXTERNAL_RELEASE   -fvisibility=hidden -fvisibility-inlines-hidden -c -DSINGLE_THREAD -O3 -mno-simd128 -fno-tree-vectorize -fPIC -flto\n为了避免O3优化添加SIMD指令，在其后面添加-mno-simd128和-fno-tree-vectorize以阻止编译器生成带SIMD指令的WASM。\n之后步骤如法炮制。结果运行时编译出来的库的有些符号未定义，查询资料得知有wasi的标准允许wasm和环境互动。emsdk编译出来的环境属于标准的wasi环境，需要对某些函数stub。"
  },
  {
    "objectID": "posts/trying-to-intergrate-z3-into-typst/index.html#第三次尝试到放弃",
    "href": "posts/trying-to-intergrate-z3-into-typst/index.html#第三次尝试到放弃",
    "title": "尝试将z3集成进typst",
    "section": "第三次尝试到放弃",
    "text": "第三次尝试到放弃\n我按照指令对关键函数stub,结果还是出现了符号未定义的问题。我将有些符号提取出来自己做了符号的定义。\n#[no_mangle]\npub extern \"C\" fn __call_sighandler(a:i32,b:i32){\n\n}\n\n#[no_mangle]\npub extern \"C\" fn _emscripten_date_now() -&gt; f64 {\n    1.0\n}\n\n#[no_mangle]\npub extern \"C\" fn _emscripten_get_now_is_monotonic() -&gt; i32 {\n    // Assume the time source is monotonic\n    1\n}\n__call_sighandler 是处理信号用的，为了方便留下了空函数，_emscripten_date_now和_emscripten_get_now_is_monotonic则是emscripten环境下获取时间的函数。我猜测z3获取时间是为了不让计算的时间超过timeout，为了简化起见我设置成了时间是固定的，永远都是单调（递增）的。\n原本以为定义了函数，又stub了不需要的函数就万事大吉了，结果最后老天给我开了一个玩笑。\nerror: plugin panicked: wasm `unreachable` instruction executed\n   ┌─ test.typ:14:11\n   │\n14 │   let ctx = z3.mk_context(cfg)\n   │             ^^^^^^^^^^^^^^^^^^\n事已至此，我认为如果要完全将z3移植到typst里，就需要深入z3的代码之中，改动可能很大，而且也不一定能成功，遂放弃。"
  },
  {
    "objectID": "posts/io-uring/index.html",
    "href": "posts/io-uring/index.html",
    "title": "关于io_uring的两三事",
    "section": "",
    "text": "io_uring 是 2019 年 Linux 5.1 内核首次引入的高性能 异步 I/O 框架，能显著加速 I/O 密集型应用的性能。 它有如下优点： - 统一了 Linux 异步 I/O 框架： Linux AIO 只支持 direct I/O 模式的存储文件（storage file） - 在设计上是真正的异步 I/O"
  },
  {
    "objectID": "posts/trying-to-intergrate-z3-into-typst/english.html",
    "href": "posts/trying-to-intergrate-z3-into-typst/english.html",
    "title": "trying to integrate Z3 into Typst",
    "section": "",
    "text": "Z3 Solver is an efficient and user-friendly theorem prover developed by Microsoft and made open-source. One day, I had a sudden inspiration to integrate it into Typst, as theoretically, a theorem prover doesn’t require interaction with other environments. However, I underestimated the complexity. Eventually, I gave up and wrote this article to document the exploration process.\n\nThe Simplest Method to Integrate Z3 into Typst\nThe simplest way to integrate Z3 into Typst is to compile it into a pure WASM file and use it as a plugin. Then, package this WASM file with a Typst file, exposing a neat interface.\nInitially, my idea was to write Rust code directly calling Z3, but I found that the Z3-sys library essentially calls the precompiled shared library, so I abandoned the pure Rust approach.\n\n\nExploring Z3 Documentation\nI began reading the Z3 documentation, but there was no direct tutorial for compiling it into WASM. However, there was an NPM package for JavaScript and WASM bindings. Following the clues, I found a file named src/api/js/scripts/build-wasm.ts with the following content:\n// ...\n// TODO (ritave): Detect if it's in the configuration we need\nif (!existsSync(path.join(z3RootDir, 'build/Makefile'))) {\n  spawnSync('emconfigure python scripts/mk_make.py --staticlib --single-threaded --arm64=false', {\n    cwd: z3RootDir,\n  });\n}\n\nspawnSync(`emmake make -j${os.cpus().length} libz3.a`, { cwd: path.join(z3RootDir, 'build') });\n\n// ...\nFrom this code, I saw that it first configures the build environment using emconfigure, then compiles a static library using emmake. This inspired me—I could first compile a compatible static library (since Z3 also provides a C interface) and then use Rust FFI to call the necessary C interfaces. Combining this with this project for convenient packaging, I could compile a WASM plugin suitable for Typst. However, the reality was not as smooth as the ideal.\n\n\nFirst Attempt\nFollowing the above TypeScript code, I configured version 3.1.15 of emsdk (to reproduce the compiler version) and compiled the static library libz3.a.\nemconfigure python scripts/mk_make.py --staticlib --single-threaded --arm64=false\ncd build\nemmake make -j$(nproc) libz3.a\nWith a static library of Z3 at hand, I enthusiastically wrote Rust code to call the static library, linked it, compiled it into a WASM file, and called the WASM with Typst. Then the unexpected happened—the environment does not support SIMD instructions.\nIt turned out that the wasmi library used by Typst does not support SIMD instructions. So, I removed the SIMD options.\n\n\nSecond Attempt\nSince Z3’s configuration options do not directly support disabling SIMD, I had to modify the config.mk file manually. The modified content is as follows:\nCXXFLAGS= -D_MP_INTERNAL -DNDEBUG -D_EXTERNAL_RELEASE  -std=c++17 -fvisibility=hidden -fvisibility-inlines-hidden -c -DSINGLE_THREAD -O3 -mno-simd128 -fno-tree-vectorize -fPIC -flto\nCFLAGS= -D_MP_INTERNAL -DNDEBUG -D_EXTERNAL_RELEASE   -fvisibility=hidden -fvisibility-inlines-hidden -c -DSINGLE_THREAD -O3 -mno-simd128 -fno-tree-vectorize -fPIC -flto\nTo avoid SIMD instructions being added by the O3 optimization, I added -mno-simd128 and -fno-tree-vectorize to prevent the compiler from generating WASM with SIMD instructions.\nFollowing the same steps, I found that some symbols were undefined at runtime. Upon further investigation, I learned that the standard wasi allows WASM and the environment to interact. The environment compiled by emsdk is a standard wasi environment, which requires stubbing some functions.\n\n\nThird Attempt and Giving Up\nFollowing the instructions, I stubbed the critical functions, but the symbol undefined issue persisted. I extracted some symbols and defined them myself.\n#[no_mangle]\npub extern \"C\" fn __call_sighandler(a: i32, b: i32) {}\n\n#[no_mangle]\npub extern \"C\" fn _emscripten_date_now() -&gt; f64 {\n    1.0\n}\n\n#[no_mangle]\npub extern \"C\" fn _emscripten_get_now_is_monotonic() -&gt; i32 {\n    // Assume the time source is monotonic\n    1\n}\n__call_sighandler is used for handling signals, and I left it as an empty function for convenience. _emscripten_date_now and _emscripten_get_now_is_monotonic are functions for getting time in the emscripten environment. I guessed that Z3 uses time to prevent calculations from exceeding a timeout, so I set the time to be constant and always monotonic (increasing).\nI thought that defining these functions and stubbing unnecessary ones would solve all problems, but in the end, fate played a trick on me.\nerror: plugin panicked: wasm `unreachable` instruction executed\n   ┌─ test.typ:14:11\n   │\n14 │   let ctx = z3.mk_context(cfg)\n   │             ^^^^^^^^^^^^^^^^^^\nAt this point, I concluded that to fully port Z3 into Typst, one would need to delve deeply into the Z3 codebase, possibly making significant changes with no guarantee of success. Therefore, I decided to give up."
  },
  {
    "objectID": "posts/convert-recursion-into-iteration/english.html",
    "href": "posts/convert-recursion-into-iteration/english.html",
    "title": "convert recursion into iteration",
    "section": "",
    "text": "Recursive function calls are a simple and understandable way to code. For certain problems, recursion can provide more concise code and more intuitive readability, such as the familiar traversal of tree structures.\nHowever, when the number of function calls becomes too many, it can lead to a common issue: stack overflow. This is because the stack space generally has strict size limits. While we can adjust the stack space size through configuration parameters, this is merely a stopgap solution and does not address the root of the problem.\nFrom another perspective, when the operating system calls a function, it saves stack information (such as the position of the next instruction after the function returns, local variables, etc.). This implicitly contains the state of each function call. The function checks this state to decide whether the stopping condition is met. Naturally, we think of using a stack data structure to simulate the process of function recursion.\nCombining the knowledge of state machines, it’s not difficult to analyze the idea of converting a recursive function to an iterative one. Suppose we have the following recursive function:\nvoid func(...args){\n    // List of local variables (function parameters are also part of local variables)\n    doSomething();\n    \n    // Recursive call appears somewhere\n    func(...args1);\n}\nThen we can set up a state structure to save the function information when the recursive version is called, with one part saving the current function variable information of the call stack and the other part saving the position during execution. If the function has a return value, a variable can be used to store it:\nenum Loc{\n    START;\n    FIRST;\n    SECOND;\n    THIRD;\n    // ...other position information\n};\nstruct State{\n    // List of local parameters\n    struct Info context;\n    // Position during execution\n    enum Loc location;\n};\nvoid func(...args){\n    stack&lt;State&gt; s;\n    State init_state = {}; // Set the initial state\n    s.push(std::move(init_state));\n    while(!s.empty()){\n        State &cnt_state = s.top();\n        switch(cnt_state.location){\n            case START:\n                doSomething();\n            case FIRST:\n                cnt_state.location = SECOND;\n                cnt_state.context = ...;\n                State new_state = {...};\n                s.push(new_state);\n                continue;\n            //....\n        }\n    }\n}\nTaking the in-order traversal of LeetCode as an example, it’s not hard to write the following recursive version:\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector&lt;int&gt; inorderTraversal(TreeNode* root) {\n        vector&lt;int&gt; res;\n        if(root == nullptr){\n            return res;\n        }\n        vector&lt;int&gt; && left = inorderTraversal(root -&gt; left);\n        res.insert(res.end(),left.begin(),left.end());\n        res.push_back(root -&gt; val);\n\n        vector&lt;int&gt; && right = inorderTraversal(root -&gt; right);\n        res.insert(res.end(),right.begin(),right.end());\n        return res;\n    }\n};\nIn-order traversal has two recursive call points: one when visiting the left subtree and another after reading the middle node to visit the right subtree. Since the important local variable in the whole function is the parameter root, the structure only needs to save one parameter. Finally, the iterative version of in-order traversal is as follows:\nenum Loc{\n    START,           // Initial state, indicating the node has just been visited\n    VISITED_LEFT,    // Left child node has been visited\n    VISITED_MIDDLE,  // Middle node has been visited\n};\n\nstruct State {\n    TreeNode *node;  // Current node\n    Loc location;    // Visit state of the current node\n};\n\nclass Solution {\npublic:\n    vector&lt;int&gt; inorderTraversal(TreeNode* root) {\n        vector&lt;int&gt; result;\n        stack&lt;State&gt; s;\n\n        // Helper function to push the node and its state into the stack\n        auto pushState = [&](TreeNode *node) {\n            s.push({node, START});\n        };\n\n        // Initial condition: push the root node if it's not null\n        if (root != nullptr) {\n            pushState(root);\n        }\n\n        // Loop to simulate recursive calls\n        while (!s.empty()) {\n            State &cnt_state = s.top(); // Get the top element of the stack, simulating the parameters and local variables of the current function call\n\n            switch (cnt_state.location) {\n                case START:\n                    // First time visiting the node, visit the left subtree first\n                    if (cnt_state.node-&gt;left != nullptr) {\n                        cnt_state.location = VISITED_LEFT;  // Change state to left child visited\n                        pushState(cnt_state.node-&gt;left);   // Push the left child node into the stack\n                        continue;                          // End the current loop early\n                    }\n                case VISITED_LEFT:\n                    // Left subtree visited, visit the current node\n                    result.push_back(cnt_state.node-&gt;val); // Add the node value to the result\n                    cnt_state.location = VISITED_MIDDLE;   // Change state to middle node visited\n                    // Visit the right subtree\n                    if (cnt_state.node-&gt;right != nullptr) {\n                        pushState(cnt_state.node-&gt;right);  // Push the right child node into the stack\n                        continue;\n                    }\n                case VISITED_MIDDLE:\n                    // Current node and its left and right subtrees have been visited, return and pop from the stack\n                    s.pop();\n                    continue;\n            }\n        }\n\n        return result;\n    }\n};"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "编程之眼",
    "section": "",
    "text": "关于io_uring的两三事\n\n\n\n\n\n\nLinux\n\n\n\n\n\n\n\n\n\nJun 29, 2024\n\n\n0warning0error\n\n\n\n\n\n\n\n\n\n\n\n\nconvert recursion into iteration\n\n\n\n\n\n\ncode\n\n\n数据结构和算法(data structure and algorithms)\n\n\n\n\n\n\n\n\n\nJun 19, 2024\n\n\n0warning0error\n\n\n\n\n\n\n\n\n\n\n\n\n将递归转成迭代\n\n\n\n\n\n\ncode\n\n\n数据结构和算法(data structure and algorithms)\n\n\n\n\n\n\n\n\n\nJun 19, 2024\n\n\n0warning0error\n\n\n\n\n\n\n\n\n\n\n\n\ntrying to integrate Z3 into Typst\n\n\n\n\n\n\ncode\n\n\ntypst\n\n\n\n\n\n\n\n\n\nJun 19, 2023\n\n\n0warning0error\n\n\n\n\n\n\n\n\n\n\n\n\n尝试将z3集成进typst\n\n\n\n\n\n\ncode\n\n\ntypst\n\n\n\n\n\n\n\n\n\nJun 19, 2023\n\n\n0warning0error\n\n\n\n\n\n\nNo matching items"
  }
]